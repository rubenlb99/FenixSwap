{"ast":null,"code":"export class Event {\n  constructor() {\n    this._listeners = new Set();\n    this._effects = new Set();\n  }\n  emit(data) {\n    for (const listener of Array.from(this._listeners)) {\n      void this._trigger(listener, data);\n    }\n  }\n  on(callback) {\n    this._listeners.add(callback);\n    if (this.listenerCount() === 1) {\n      this._runEffects();\n    }\n    return () => this.off(callback);\n  }\n  off(callback) {\n    this._listeners.delete(callback);\n    if (this.listenerCount() === 0) {\n      this._cleanupEffects();\n    }\n  }\n  listenerCount() {\n    return this._listeners.size;\n  }\n  addEffect(effect) {\n    const handle = {\n      effect,\n      cleanup: undefined\n    };\n    if (this.listenerCount() > 0) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n    this._effects.add(handle);\n    return () => {\n      var _a;\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      this._effects.delete(handle);\n    };\n  }\n  async _trigger(listener, data) {\n    try {\n      await waitImmediate(); // Acts like setImmediate but preserves the stack-trace.\n      listener(data);\n    } catch (error) {\n      // Stop error propagation.\n      throwUnhandledRejection(error);\n    }\n  }\n  _runEffects() {\n    for (const handle of Array.from(this._effects)) {\n      const cleanup = handle.effect();\n      if (typeof cleanup === 'function') {\n        handle.cleanup = cleanup;\n      }\n    }\n  }\n  _cleanupEffects() {\n    var _a;\n    for (const handle of Array.from(this._effects)) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n      handle.cleanup = undefined;\n    }\n  }\n}\nfunction throwUnhandledRejection(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise(resolve => setTimeout(resolve));","map":{"version":3,"sources":["../../../../src/helpers/event.ts"],"names":[],"mappings":"AAiBA,OAAM,MAAO,KAAK,CAAA;EAAlB,WAAA,GAAA;IACmB,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAqB;IACzC,IAAA,CAAA,QAAQ,GAAG,IAAI,GAAG,EAAsB;EA0E3D;EAxEE,IAAI,CAAC,IAAO,EAAA;IACV,KAAK,MAAM,QAAQ,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;MAClD,KAAK,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC;IACnC;EACH;EAEA,EAAE,CAAC,QAA2B,EAAA;IAC5B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC;IAE7B,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;MAC9B,IAAI,CAAC,WAAW,EAAE;IACnB;IAED,OAAO,MAAM,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC;EACjC;EAEA,GAAG,CAAC,QAA2B,EAAA;IAC7B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC;IAEhC,IAAI,IAAI,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE;MAC9B,IAAI,CAAC,eAAe,EAAE;IACvB;EACH;EAEA,aAAa,GAAA;IACX,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI;EAC7B;EAEA,SAAS,CAAC,MAAc,EAAA;IACtB,MAAM,MAAM,GAAuB;MAAE,MAAM;MAAE,OAAO,EAAE;IAAS,CAAE;IAEjE,IAAI,IAAI,CAAC,aAAa,EAAE,GAAG,CAAC,EAAE;MAC5B,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;MAC/B,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;QACjC,MAAM,CAAC,OAAO,GAAG,OAAO;MACzB;IACF;IAED,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC;IACzB,OAAO,MAAK;;MACV;MACA,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,MAAA,CAAI;MAClB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;IAC9B,CAAC;EACH;EAEQ,MAAM,QAAQ,CAAC,QAA2B,EAAE,IAAO,EAAA;IACzD,IAAI;MACF,MAAM,aAAa,EAAE,CAAA,CAAC;MACtB,QAAQ,CAAC,IAAI,CAAC;KACf,CAAC,OAAO,KAAU,EAAE;MACnB;MACA,uBAAuB,CAAC,KAAK,CAAC;IAC/B;EACH;EAEQ,WAAW,GAAA;IACjB,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;MAC9C,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,EAAE;MAC/B,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;QACjC,MAAM,CAAC,OAAO,GAAG,OAAO;MACzB;IACF;EACH;EAEQ,eAAe,GAAA;;IACrB,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;MAC9C;MACA,CAAA,EAAA,GAAA,MAAM,CAAC,OAAO,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,MAAA,CAAI;MAClB,MAAM,CAAC,OAAO,GAAG,SAAS;IAC3B;EACH;AACD;AAED,SAAS,uBAAuB,CAAC,KAAY,EAAA;EAC3C,UAAU,CAAC,MAAK;IACd,MAAM,KAAK;EACb,CAAC,CAAC;AACJ;AAEA;;AAEG;AACH,MAAM,aAAa,GAAG,MAAM,IAAI,OAAO,CAAE,OAAO,IAAK,UAAU,CAAC,OAAO,CAAC,CAAC","sourceRoot":"","sourcesContent":["export class Event {\n    constructor() {\n        this._listeners = new Set();\n        this._effects = new Set();\n    }\n    emit(data) {\n        for (const listener of Array.from(this._listeners)) {\n            void this._trigger(listener, data);\n        }\n    }\n    on(callback) {\n        this._listeners.add(callback);\n        if (this.listenerCount() === 1) {\n            this._runEffects();\n        }\n        return () => this.off(callback);\n    }\n    off(callback) {\n        this._listeners.delete(callback);\n        if (this.listenerCount() === 0) {\n            this._cleanupEffects();\n        }\n    }\n    listenerCount() {\n        return this._listeners.size;\n    }\n    addEffect(effect) {\n        const handle = { effect, cleanup: undefined };\n        if (this.listenerCount() > 0) {\n            const cleanup = handle.effect();\n            if (typeof cleanup === 'function') {\n                handle.cleanup = cleanup;\n            }\n        }\n        this._effects.add(handle);\n        return () => {\n            var _a;\n            // eslint-disable-next-line no-unused-expressions\n            (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n            this._effects.delete(handle);\n        };\n    }\n    async _trigger(listener, data) {\n        try {\n            await waitImmediate(); // Acts like setImmediate but preserves the stack-trace.\n            listener(data);\n        }\n        catch (error) {\n            // Stop error propagation.\n            throwUnhandledRejection(error);\n        }\n    }\n    _runEffects() {\n        for (const handle of Array.from(this._effects)) {\n            const cleanup = handle.effect();\n            if (typeof cleanup === 'function') {\n                handle.cleanup = cleanup;\n            }\n        }\n    }\n    _cleanupEffects() {\n        var _a;\n        for (const handle of Array.from(this._effects)) {\n            // eslint-disable-next-line no-unused-expressions\n            (_a = handle.cleanup) === null || _a === void 0 ? void 0 : _a.call(handle);\n            handle.cleanup = undefined;\n        }\n    }\n}\nfunction throwUnhandledRejection(error) {\n    setTimeout(() => {\n        throw error;\n    });\n}\n/**\n * Like setImmediate but for async/await API. Useful for preserving stack-traces.\n */\nconst waitImmediate = () => new Promise((resolve) => setTimeout(resolve));\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}