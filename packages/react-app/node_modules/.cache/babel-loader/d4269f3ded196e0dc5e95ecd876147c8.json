{"ast":null,"code":"import { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  if (!contract.address || !method) {\n    throw new Error('Missing contract address or method name');\n  }\n  try {\n    contract.interface.encodeFunctionData(method, args);\n    return call;\n  } catch (err) {\n    throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`);\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  if (!call) {\n    return undefined;\n  }\n  try {\n    validateCall(call);\n  } catch (e) {\n    return e;\n  }\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n  const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n  return {\n    address: contract.address,\n    data: contract.interface.encodeFunctionData(method, args),\n    chainId,\n    isStatic,\n    refreshPerBlocks\n  };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n      const currentBlock = options.blockNumber;\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n    callsForUpdate.push(request);\n  }\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n  var _a;\n  if (!result || !call) {\n    return undefined;\n  }\n  const {\n    value,\n    success\n  } = result;\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n  if (data === '0x') {\n    return 'Call reverted without a cause message';\n  }\n  if (data.startsWith('0x08c379a0')) {\n    // decode Error(string)\n    const reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n    if (reason.startsWith('VM Exception')) {\n      return defaultMulticall1ErrorMessage;\n    }\n    return reason;\n  }\n  if (data.startsWith('0x4e487b71')) {\n    // decode Panic(uint)\n    const code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n    return `panic code ${code._hex}`;\n  }\n  try {\n    const errorInfo = contractInterface.parseError(data);\n    return `error ${errorInfo.name}`;\n  } catch (e) {\n    console.error(e);\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\nimport { defaultMulticall1ErrorMessage } from '../abi/multicall/constants';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function validateCall(call) {\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        throw new Error('Missing contract address or method name');\n    }\n    try {\n        contract.interface.encodeFunctionData(method, args);\n        return call;\n    }\n    catch (err) {\n        throw new Error(`Invalid contract call for method=\"${method}\" on contract=\"${contract.address}\": ${err.message}`);\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n * @returns\n * One of these:\n * - a RawCall, if encoding is successful.\n * - Falsy, if there is no call to encode.\n * - an Error, if encoding fails (e.g. because of mismatched arguments).\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n    var _a;\n    if (!call) {\n        return undefined;\n    }\n    try {\n        validateCall(call);\n    }\n    catch (e) {\n        return e;\n    }\n    const { contract, method, args } = call;\n    const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n        address: contract.address,\n        data: contract.interface.encodeFunctionData(method, args),\n        chainId,\n        isStatic,\n        refreshPerBlocks,\n    };\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n    const callsForUpdate = [];\n    for (const request of requests) {\n        if (options) {\n            if (options.chainId && options.chainId !== request.chainId) {\n                continue;\n            }\n            if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n                continue;\n            }\n            const currentBlock = options.blockNumber;\n            if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n                if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n                    continue;\n                }\n            }\n        }\n        callsForUpdate.push(request);\n    }\n    return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    var _a;\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = (_a = tryDecodeErrorData(value, call.contract.interface)) !== null && _a !== void 0 ? _a : 'Unknown error';\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\nfunction tryDecodeErrorData(data, contractInterface) {\n    if (data === '0x') {\n        return 'Call reverted without a cause message';\n    }\n    if (data.startsWith('0x08c379a0')) {\n        // decode Error(string)\n        const reason = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', data)[0];\n        if (reason.startsWith('VM Exception')) {\n            return defaultMulticall1ErrorMessage;\n        }\n        return reason;\n    }\n    if (data.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const code = new utils.Interface(['function Panic(uint)']).decodeFunctionData('Panic', data)[0];\n        return `panic code ${code._hex}`;\n    }\n    try {\n        const errorInfo = contractInterface.parseError(data);\n        return `error ${errorInfo.name}`;\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}