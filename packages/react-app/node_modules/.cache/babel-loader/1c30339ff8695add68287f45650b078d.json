{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { providers } from 'ethers';\nimport { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport { useConfig, useLocalStorage } from '../../../hooks';\nimport { ConnectorController } from './connectorController';\nimport { InjectedConnector } from './implementations';\nconst Provider = providers.Provider;\nconst Web3Provider = providers.Web3Provider;\nexport const ConnectorContext = createContext({\n  connector: undefined,\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activate: async () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  deactivate: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activateBrowserWallet: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  reportError: () => {},\n  isLoading: false\n});\nexport function ConnectorContextProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  const [controller, setController] = useState();\n  const [isLoading, setLoading] = useState(false);\n  const config = useConfig();\n  const {\n    connectors,\n    autoConnect\n  } = config;\n  const [autoConnectTag, setAutoConnectTag] = useLocalStorage('usedapp:autoConnectTag');\n  const activate = useCallback(async function (providerOrConnector) {\n    let {\n      silently,\n      onSuccess\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      silently: false\n    };\n    let controller;\n    if ('activate' in providerOrConnector) {\n      controller = new ConnectorController(providerOrConnector, config);\n    } else {\n      const wrappedProvider = Provider.isProvider(providerOrConnector) ? providerOrConnector : new Web3Provider(providerOrConnector);\n      controller = new ConnectorController(new InjectedConnector(wrappedProvider), config);\n    }\n    setLoading(true);\n    try {\n      if (silently) {\n        await controller.activate(connector => connector.connectEagerly());\n      } else {\n        await controller.activate();\n      }\n      setController(controller);\n      setLoading(false);\n      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n    } catch (error) {\n      controller.reportError(error);\n    } finally {\n      setLoading(false);\n    }\n  }, [setController, setLoading]);\n  const activateBrowserWallet = useCallback(async options => {\n    // done for backward compatibility.\n    // If the options object looks like an event object or is undefined,\n    // it's not a valid option and will be ignored\n    if (!options || typeof options.preventDefault === 'function') {\n      options = {\n        type: 'metamask'\n      };\n    }\n    const {\n      type\n    } = options;\n    if (!connectors[type]) {\n      throw new Error(`Connector ${type} is not configured`);\n    }\n    await activate(connectors[type], {\n      onSuccess: () => {\n        setAutoConnectTag(type);\n      }\n    });\n  }, [activate, setAutoConnectTag, connectors]);\n  useEffect(() => {\n    if (autoConnect && autoConnectTag && connectors[autoConnectTag]) {\n      void activate(connectors[autoConnectTag], {\n        silently: true\n      });\n    }\n  }, []);\n  useEffect(() => {\n    controller === null || controller === void 0 ? void 0 : controller.updateConfig(config);\n  }, [controller, config]);\n  return _jsx(ConnectorContext.Provider, Object.assign({\n    value: {\n      connector: controller,\n      deactivate: async () => {\n        setAutoConnectTag(undefined);\n        setLoading(true);\n        await (controller === null || controller === void 0 ? void 0 : controller.deactivate());\n        setController(undefined);\n        setLoading(false);\n      },\n      reportError: err => {\n        controller === null || controller === void 0 ? void 0 : controller.reportError(err);\n      },\n      activate,\n      activateBrowserWallet,\n      isLoading\n    }\n  }, {\n    children: children\n  }));\n}\nexport const useConnector = () => useContext(ConnectorContext);","map":{"version":3,"sources":["../../../../../../src/providers/network/connectors/context.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { providers } from 'ethers';\nimport { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport { useConfig, useLocalStorage } from '../../../hooks';\nimport { ConnectorController } from './connectorController';\nimport { InjectedConnector } from './implementations';\nconst Provider = providers.Provider;\nconst Web3Provider = providers.Web3Provider;\nexport const ConnectorContext = createContext({\n    connector: undefined,\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    activate: async () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    deactivate: () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    activateBrowserWallet: () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    reportError: () => { },\n    isLoading: false,\n});\nexport function ConnectorContextProvider({ children }) {\n    const [controller, setController] = useState();\n    const [isLoading, setLoading] = useState(false);\n    const config = useConfig();\n    const { connectors, autoConnect } = config;\n    const [autoConnectTag, setAutoConnectTag] = useLocalStorage('usedapp:autoConnectTag');\n    const activate = useCallback(async (providerOrConnector, { silently, onSuccess } = { silently: false }) => {\n        let controller;\n        if ('activate' in providerOrConnector) {\n            controller = new ConnectorController(providerOrConnector, config);\n        }\n        else {\n            const wrappedProvider = Provider.isProvider(providerOrConnector)\n                ? providerOrConnector\n                : new Web3Provider(providerOrConnector);\n            controller = new ConnectorController(new InjectedConnector(wrappedProvider), config);\n        }\n        setLoading(true);\n        try {\n            if (silently) {\n                await controller.activate((connector) => connector.connectEagerly());\n            }\n            else {\n                await controller.activate();\n            }\n            setController(controller);\n            setLoading(false);\n            onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n        }\n        catch (error) {\n            controller.reportError(error);\n        }\n        finally {\n            setLoading(false);\n        }\n    }, [setController, setLoading]);\n    const activateBrowserWallet = useCallback(async (options) => {\n        // done for backward compatibility.\n        // If the options object looks like an event object or is undefined,\n        // it's not a valid option and will be ignored\n        if (!options || typeof options.preventDefault === 'function') {\n            options = { type: 'metamask' };\n        }\n        const { type } = options;\n        if (!connectors[type]) {\n            throw new Error(`Connector ${type} is not configured`);\n        }\n        await activate(connectors[type], {\n            onSuccess: () => {\n                setAutoConnectTag(type);\n            },\n        });\n    }, [activate, setAutoConnectTag, connectors]);\n    useEffect(() => {\n        if (autoConnect && autoConnectTag && connectors[autoConnectTag]) {\n            void activate(connectors[autoConnectTag], {\n                silently: true,\n            });\n        }\n    }, []);\n    useEffect(() => {\n        controller === null || controller === void 0 ? void 0 : controller.updateConfig(config);\n    }, [controller, config]);\n    return (_jsx(ConnectorContext.Provider, Object.assign({ value: {\n            connector: controller,\n            deactivate: async () => {\n                setAutoConnectTag(undefined);\n                setLoading(true);\n                await (controller === null || controller === void 0 ? void 0 : controller.deactivate());\n                setController(undefined);\n                setLoading(false);\n            },\n            reportError: (err) => {\n                controller === null || controller === void 0 ? void 0 : controller.reportError(err);\n            },\n            activate,\n            activateBrowserWallet,\n            isLoading,\n        } }, { children: children })));\n}\nexport const useConnector = () => useContext(ConnectorContext);\n//# sourceMappingURL=context.js.map"]},"metadata":{},"sourceType":"module"}